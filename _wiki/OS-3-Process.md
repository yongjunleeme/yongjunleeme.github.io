---
layout  : wiki
title   : 
summary : 
date    : 2022-02-13 00:06:40 +0900
updated : 2022-03-09 11:49:43 +0900
tags    : 
toc     : true
public  : true
parent  : 
latex   : false
---
* TOC
{:toc}

## 프로세스의 개념

- Process is program in execution
	- 실행시작 --> 프로세스 독자적 주소공간(Code, data, stack) 생성 --> 프로세스에 CPU 할당되면 프로그램 카운터가 프로세스 주소공간의 하나를 가리킨다 -> code에서 Instruction(기계어)를 하나씩 읽어서 CPU 안으로 불러들인다.  -> CPU 내부의 레지스터에 값을 넣고 논리연산장치에서 연산한다 -> 결과를 레지스터나 바깥의 메모리에 저장
- 프로세스의 문맥(Context): 프로그램의 특정 시점	
	- CPU 수행 상태를 나타내는 하드웨어 문맥
		- 프로그램 카운터가 어디를 가리키고 있는가(=코드의 어느 부분까지 실행했는가)
		- 각종 레지스터
	- 프로세스 주소 공간
		- 메모리에 어떤 내용을 담고 있는가
		- code, data(변수 등), stack
	- 프로세스 관련 커널 자료 구조
		- PCB(Process Control Block): 프로세스 실행될 때마다 실행, 프로세스를 관리하기 위한 용도
		- 커널 스택: 프로세스를 OS에게 맡길 때 --> 커널스택을 따로 둔다. 

## 프로세스의 상태

Running
- CPU를 잡고 인스트럭션을 수행 중인 상태

Ready
- 다른 모든 준비 완료, CPU만 오면 되는

Blocked(wait, sleep)
- CPU를 줘도 당장 인스트럭션 수행 불가능한 상태 예) I/O

Suspended(stopped)
- 외부적인 이유로 프로세스의 수행이 정지된 상태
- 예를 들어 중기 스케줄러에 의해 생기는 상태
- 프로세스는 통째로 디스크에 swap out된다.
- 예) 사용자 프로그램이 일시정지시킨 경우, 시스템이 여러 이유로 프로세스를 잠시 중단시킴(메모리에 너무 많은 프로세스가 올라와 있을 때) 

Etc
- Blocked: 자신이 요청한 이벤트가 만족되면 Ready
- Suspended: 외부에서 재개해주어야 Active
- New: 프로세스 생성 중인 상태
- Terminated: 수행(execution)이 끝난 상태, 약간 정리할 게 남음

- 유의
    - 프로세스가 시스템콜을 해 운영체제가 제어한다고 운영체제가 운영을하고 있다고 말하지 않는다. 커널 모드에서 러닝한다고 말한다.

### PCB

- 운영체제가 각 프로세스를 관리하기 위해 프로세스당 유지하는 정보
- 구조체로 유지

- 1) OS 관리상 사용하는 정보
    - Process state, Process ID
    - Scheduling information, priority
 
- 2) CPU 수행 관련 하드웨어 값(문맥)
    - 프로그램 카운터, 레지스터

- 3) 메모리 관련(문맥)
    -  code, data, stack의 위치 정보

- 4) 파일 관련
    - Open file descriptors 

### 문맥 교환(Context Switch)

- CPU를 한 프로세스에서 다른 프로세스로 넘겨주는 과정
	- CPU를 내어주는 프로세스 상태를 그 프로세스의 PCB에 저장
	- CPU를 새롭게 얻는 프로세스의 상태를 PCB에서 읽어옴
 
- 시스템 콜이나 인터럽트 발생한다고 반드시 컨텍스트 스위칭은 아님
- 사용자 프로세스 하나에서 다른 사용자 프로세스로 넘어가는 상황에서 일어나는 것이 컨텍스트 스위칭
- 인터럽트 발생한 것은 컨텍스트 스위칭이 아니지만 OS가 다른 프로세스에게 넘겨주는 상태는 컨텍스트 스위칭(예: 타이머 인터럽트: 타이머로 시간이 지나면 다른 프로세스에 제어권을 넘겨야 하므로 그 사이 문맥교환이 일어남)
- 예) 캐시: 일반 CPU 컨텍스트 스위칭에서는 지우지 않지만 사용자 프로세스가 바뀌는 컨텍스트 스위칭에서는 캐시를 지운다.

### 프로세스를 스케줄링하기 위한 큐

- 1) Job queue
 - 현재 시스템 내에 있는 모든 프로세스의 집합

- 2) Ready queue
    - 현재 메모리 내에 있으면서 CPU를 잡아서 실행되기를 기다리는 프로세스의 집합

- 3) Device queues
    - I/O device의 처리를 기다리는 프로세스의 집합 

프로세스들은 각 큐들을 오가며 수행된다.

## 스케줄러

- 1) Long-term scheduler
    - 어떤 프로세스가 NEW 상태에 있는데 여기에 메모리를 줄 지 안 줄 지 결정
    - 시작 프로세스 중 어떤 것들을 Ready queue로 보낼지 결정
    - degree of multiprogramming(메모리에 올라간 프로세스의 수)을 제어
    - Time sharing system에는 보통 장기 스케줄러가 없음(무조건 Ready)
지금은 없는 시스템 무조건 Ready로 감. 중기 스케줄러가 현재 시스템

- 2) Short-term scheduler(CPU 스케줄러)
    - 어떤 프로세스를 다음번에 러닝시킬지 결정

- 3) Medium-term scheduler(Swapper)
    - 여유 공간 마련을 위해 프로세스를 통째로 메모리에서 디스크로 쫓아냄
    - 프로세스에게서 메모리를 뺏는 문제
    - degree of multiprogramming(메모리에 올라간 프로세스의 수)을 제어

## 쓰레드

쓰레드는 CPU를 수행하는 단위(lightweight process)  

- 프로세스 내부에 CPU 수행 단위가 여러 개 있는 것
- 프로세스 주소공간은 하나만 띄워놓고 코드의 각 다른 부분을 실행
- CPU 수행을 위해 프로그램 카운터, 레지스터 별도로 유지
- 코드를 실행하다가 함수호출하면 정보를 스택에 쌓을텐데 스택도 별도로 유지

- 결국 공유할 수 있는 것들은 공유하고(메모리 주소공간, 프로세스 상태, 프로세스 자원)
- CPU 수행 관련된 정보는 별도로 가지고 있는다(프로그램 카운터, 레지스터, 스택)

쓰레드의 구성
- 프로그램 카운터, 레지스터, 스택

쓰레드끼리 공유하는 부분(=Task)
- code, data, os 리소스

쓰레드 사용 장점
- 한 쓰레드가 Blocked 상태일 때 다른 쓰레드가 Running하여 응답속도를 높일 수 있다.
    - 예) 웹 브라우저 네이버 웹페이지 읽어온다(I/O 작업) 아무것도 못하면 답답하니 어려 개 쓰레드로 하면 그림 불러오고 텍스트 불러오고 따로 쓰레드로
- 동일한 일을 수행하는 다중 스레드가 협력해 높은 처리율(throughput)
    - 예) 같은 일 프로세스 여러 개 띄우면 각각 메모리에 올라가야 하기 때문에 메모리 낭비
- 병렬성을 높인다. (CPU가 여러 개일 경우)
    - 예) 1000 by 1000 행렬 연산 각 계산을 서로 다른 CPU에서 연산하고 합친다.

- 1) 응답성
- 2) 자원공유
- 3) 경제성
    - 프로세스에서 쓰레드 만들기는 쉽다 & CPU 스위칭 쓰레드가 프로세스 스위칭보다 낫다
    - Solaris의 경우 위 두 가지 오버에드가 각각 30배, 5배 차이남
    - 가능하면 같은 일을 할 때는 프로세스 여러 개보다는 프로세스 하나에 쓰레드 여러 개가 낫다는 이야기
- 4) 멀티프로세서 유틸라이제이션(CPU여러 개일 때만)
    - 높은 parallel 병렬성

쓰레드 구현
- 1) 커널 --> 커널 쓰레드
운영체제가 쓰레드가 여러 개라는 것을 알고 있다
쓰레드도 스케줄링한다
- 2) 라이브러리 --> 유저 쓰레드
운영체제는 쓰레드 여러 개인지 모르고 유저가 운영한다.
- 3) 리얼타임 쓰레드

## Source

- [이화여대 반효경 교수님 운영체제 강의](http://www.kocw.net/home/search/kemView.do?kemId=1046323)

