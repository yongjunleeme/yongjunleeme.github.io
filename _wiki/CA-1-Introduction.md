---
layout  : wiki
title   : 
summary : 
date    : 2022-02-13 00:20:20 +0900
updated : 2022-06-18 17:42:11 +0900
tags    : 
toc     : true
public  : true
parent  : 
latex   : false
---
* TOC
{:toc}

 ## 1.2 컴퓨터 구조 분야의 일곱 가지 위대한 아이디어

### 1) 설계를 단순화하는 추상화
하위 수준의 상세한 사항을 안 보이게 함으로써 상위 수준 모델을 단순화한다.

### 2) 자주 생기는 일을 빠르게(Common case fast)
### 3) 병렬성(parallelism)을 통한 성능 개선
### 4) 파이프라이닝을 통한 성능 개선
### 5) 예측을 통한 개선
예측이 틀렸을 때 이를 복구하는 비용이 비싸지 않고 예측이 맞을 확률이 비교적 높을 경우, 확실해질 때까지 기다리는 것보다 추측해서 일단 시작하는 것이 평균적으로 빠를 수 있다.

### 6) 메모리 계층구조
### 7) 여유분을 이용한 신용도 개선

## 1.3 프로그램 밑의 세계

하드웨어 - 시스템 소프트웨어 - 애플리케이션 소프트웨어

시스템 소프트웨어에는 운영체제와 컴파일러가 있다.

컴파일러는 상위 수준언어로 작성된 프로그램을 하드웨어가 실행할 명령어(기계어)로 번역한다.

어셈블러는 기호로 된 명령어를 이진수로 바꾸어 준다(예: `add A, B` --> `1001010100101110`)

## 1.4 케이스를 열고

### 상자를 열고
모든 컴퓨터 하드웨어는 4가지 기본기능인 데이터 입력, 출력, 처리 저장을 수행한다.

DRAM(Dynamic Random Access Memory): 어떤 위치든 임의로 접근할 수 있다. DRAM 여러 개를 한데 묶어서 프로그램의 명령어와 데이터를 기억하는 데 사용한다. DRAM에서 RAM이란 말은 자기 테이프 같은 순차 접근 메모리와는 반대로 메모리의 어떤 부분을 읽든지 같은 시간이 걸린다는 것을 의미한다.

캐시 메모리는 DRAM의 버퍼 역할을 하는 작고 빠른 메모리다(비전문적인 용어로 캐시는 물건을 숨겨 두기에 안전한 장소라는 뜻이다). 캐시는 SRAM(Static Random Access Memory)을 이용하는데 SRAM은 DRAM보다 빠르지만 집적도가 낮아서 가격이 비싸다.

명령어 집합(Instruction Set Architecture) 중 응용 프로그래머에게 제공되는 기본 명령어 집합과 운영체제 인터페이스를 합쳐서 ABI(Application Binary Interface)라 한다.

여러 계층의 추상화 중에서 가장 중요한 것은 하드웨어와 하위 계층 소프트웨어 간의 인터페이스인 명령어 집합 구조(Instruction Set Architecture)다. 이렇게 인터페이스를 추상화함으로써 같은 소프트웨어를 실행하지만 가격과 성능이 다른 여러 가지 컴퓨터를 구현할 수 있다.

### 데이터의 안전한 저장소
- 휘발성(Volatile) 메모리(=Main Memory, Primary Memory)
- 비휘발성 메모리(Secondary Memory)

플래시 메모리는 10만~100만번 쓰기를 한 후에는 못 쓰게 된다.

### 컴퓨터 간의 통신
이더넷은 근거리 네트워크(LAN)의 일종이다. 라우팅 서비스와 보안을 제공하는 스위치를 사용하면 LAN들을 서로 연결할 수 있다. 

## 1.5 프로세서와 메모리 생산 기술

트랜지스터는 전기로 제어되는 온/오프 스위치다.

집적회로는 수십, 수백 개의 트랜지스터를 칩 하나에 집적시킨 것이다.

집적회로 칩의 생산은 모래의 구성 성분인 실리콘에서부터 출발한다. 실리콘은 전기가 통하기는 하는데 썩 잘 통하는 편은 아니어서 반도체라고 부른다.

실리콘 결정 괴(silicon crystal ingot)을 0.1인치 이하 두께로 잘라 웨이퍼로 만든다.

웨이퍼에 화학 물질을 첨가해 부분 부분을 도체, 절연체로 바꾼다.

웨이퍼를 컴포넌트별로 자르는데 이를 다이(die) 또는 칩이라 한다.

여러 조각으로 나눠 웨이퍼 전체를 버리는 대신 다이만 버리면 된다.

트랜지스터와 연결선의 크기를 줄여서 다이를 축소시켜 원가 절감을 꾀하는데 2020년 최첨단 공정은 7nm다.

## 1.6 성능

### 성능의 정의

사용자 입장에서는 응답시간(작업 개시부터 종료까지의 시간), 데이터 관리자에게는 처리량 혹은 대역폭(일정한 시간 동안 처리하는 작업의 양)이 중요하다.

여기서는 성능을 논할 때 응답시간에 초점을 맞출 것이다.

$$성능x = \frac{ 1}  { 실행시간x } $$
### 성능의 측정

경과시간(elapsed time)은 한 작업을 끝내는 데 필요한 전체 시간(디스크 접근, 메모리 적븐, 입출력 작업, 운영체제 오버헤드 등)인데 이와 구분해서 CPU 실행 시간(CPU execution time) 또는 CPU 시간에는 입출력이나 다른 프로그램 실행 시간은 포함되지 않는다.

CPU 시간은 사용자 CPU 시간과 운영체제가 이 프로그램을 위한 작업을 수행하기 위해 소비한 시스템 CPU 시간으로 다시 나눌 수 있다.

다른 부하가 없는 시스템에서의 경과시간으로 계산한 것을 시스템 성능, 사용자 CPU 시간으로 계산한 것을 CPU 성능이라고 부르기로 한다. 여기서는 CPU 성능에 초점을 맞춘다.

### CPU 성능과 성능 인자

프로그램의 CPU 실행 시간 = 프로그램의 CPU 클럭 사이클 수 * 클럭 사이클 시간

$$프로그램의 CPU 실행시간 = \frac{프로그램의 CPU 클럭 사이클 수} {클럭 속도}  $$


### 명령어 성능

$$CPU 클럭 사이클 수 = \frac{명령어 수} {명령어당 평균 클럭 사이클 수}  $$

명령어당 클럭 사이클 수(clock cycles per instruction)은 CPI로 줄여 쓰기도 한다.


### 고전적인 CPU 성능식

CPU 시간 = 명령어 개수 * CPI * 클럭 사이클 시간

$$CPU 시간 = \frac{명령어 개수 * CPI} {클럭 속도}  $$

어떤 프로세서는 매 클럭 사이클마다 여러 개의 명령어를 인출하고 수행한다. 이에 CPI의 역수인 IPC(Instructions Per Clock Cycle, 클럭 사이클당 명령어 수)를 사용할 수도 있다. 어떤 프로세서가 클럭 사이클당 평균 2개의 명령어를 수행한다면 IPC는 2가 되고 CPI는 0.5가 되는 것이다.

클럭 속도는 평균 클럭 속도를 사용할 필요가 있다. 최근 프로세서는 에너지 절약이나 성능 향상을 위해 클럭 속도를 변경시키기도 하기 때문이다. Intel Core i7은 칩이 너무 뜨거워지기 전에 한시적으로 클럭 속도를 10% 정도 올리는데 이를 터보 모드(Turbo mode)라고 부른다.

## 1. 7 전력 장벽

MIPS 같이 처리 속도보다 실행시간을 초 단위로 측정하는 것이 더 좋은 성능 측정 방법인 것처럼 단위 시간당 에너지(joule/sec)인 와트(watt)보다 에너지 척도인 줄(joule)이 더 나은 척도이다.

집적회로의 주된 기술인 CMOS(Complementary Metal Oxide Semiconductor)가 에너지를 소비하는 주원인은 동적 에너지(Dynamic Energy)다. 동적 에너지란 트랜지스터가 0에서 1로 혹은 그 반대로 스위칭하는 동안에 소비되는 에너지를 말한다.

동적 에너지가 CMOS 에너지 소모의 주요인이지만 트랜지스터가 꺼져 있을 때도 흐르는 누설 전류 때문에 정적 에너지 소모가 존재한다. 서버에서 전체 에너지 소모의 40%는 누설 전류에 의한 것이다. 트랜지스터가 많아지면 전원이 꺼져 있더라도 전력 소모가 늘어나는 것이다.

전력은 다음 두 가지 이유로 집적회로의 골치 아픈 문제다. 첫째는 전력이 칩 전체로 전달되어야 하는 점이다. 프로세서는 전력과 접지를 위해 수백 개의 핀을 사용하는데 칩 연결망 중 여러 층이 전력과 접지만을 위해 사용된다. 둘째는 전력이 열로 낭비되므로 열을 제거해야 한다는 것이다.

## 1.8 현저한 변화: 단일프로세서에서 멀티프로세서로의 변화

코어의 응답시간 개선 추세는 매년 1.5배에서 2002년부터 1.03배가량으로 둔화됐다. 전력 한계 문제 때문이다.

이에 서버 회사는 단일 코어가 아닌 여러 개의 프로세서를 집적한 마이크로프로세서(코어)를 내놓았고 이는 응답시간보다 처리량 개선에 더 효과가 있다.

### 하드웨어/소프트웨어 인터페이스

프로그래머가 명시적으로 병렬 프로그램을 작성하는 것이 왜 이렇게 어려운 일인가?

각 프로세서가 대략 비슷한 양의 일을 동시에 수행하도록 분할해야 한다. 서브태스크들을 스케줄링해야 할 뿐만 아니라 부하를 공평하게 분배해야 하기 때문이다. 

또한 스케줄링하고 조정하는데 오버헤드는 작아야 한다. 스케줄링, 부하 균형, 동기화 시간, 참여자들 간의 통신 오버헤드를 줄이는 것은 어려운 문제이다.

## 1.9 실례 Intel Core i7 벤치마킹
### SPEC CPU 벤치마크

보통은 성능을 측정하기 위해 선택된 프로그램의 집합, 즉 벤치마크를 사용해서 성능을 평가한다.

벤치마크는 사용자의 실제 작업부하(Workload)에 대한 성능을 잘 반영할 프로그램들로 구성한 작업부하다.

SPEC(System Performance Evaluation Cooperative)은 최신 컴퓨터 시스템을 위한 표준 벤치마크를 만들기 위해 여러 컴퓨터 회사가 자금을 대 만들었다.

가장 최근 발표된 SPEC CPU2017은 정수 벤치마크 1개, 부동소수점 벤치마크 13개로 구성된다.

- SPEC 정수형 벤치마크 프로그래과 i7의 실행시간

![i7_benchmark](https://user-images.githubusercontent.com/48748376/173238629-a7ec25f2-0c34-4556-b976-db982b79c0a5.png)


### SPEC 전력 벤치마크

에너지와 전력의 중요성이 증대하면서 SPEC은 전력 측정을 위한 벤치마크를 추가했다.

이는 일정 시간 동안 작업부하를 10%씩 증가시키면서 서버의 전력 소모를 측정한다.

## Instruction Set Architecture as an ADT
- ISA는 인터페이스다. 목적은 분업이다.
- 레지스터와 메모리로 정의된 상태, 그 상태를 Transform시킬 수 있는 명령어로 구성
- ADT(Abstract Data Type)	
	- 무엇이 정의되어야 하나? State와 State를 변경하는 Operation

- 예:
	- Jump는 어떤 State을 바꾸나? 프로그램 카운터 스테이트 1개만 바꾼다
	- Store? 프로그램 카운터의 값, 메모리의 한 location의 값을 바꾼다.
	- State는 레지스터의 집합 + 메모리로 정의, Operation은 Instruction으로 정의

## Design Techniques 
- Pipelined execution : 한 명령어 실행 이후 끝마치기 전에 다음 명령어 실행
- out-of-order execution: 뒤죽박죽 실행
- Speculative Execution(추측에 근거한 실행): 브랜치를 만나면 결과를 보지 않고 예측을 해서 양쪽 중에 한 방향으로 가능 가버리는 것?

## Engineering methodology 
- Rule1: Common 케이스는 성능 최적화
- Rule2: Rare 케이스는 성능보다 Correct 

### Rule1: Common 케이스는 성능 최적화
- 메인메모리: DRAM으로 구성(캐시보다 훨씬 큰 규모)
- 캐시: SRAM(가격비싸고 속도 빠름)으로 구성
- SRAM과 DRAM 사이의 Trade off: cost, performance
- 목표: 새로운 메모리 소자의 성능은 SRAM이며 가격은 DRAM인 것 같은 일루젼

- Spatial locality(공간적 지역성): 어떤 주소가 참조되면 가까운 미래에 그 주소가 또 참조될 확률이 높다.
- Temporal locality(시간적 지역성): 가까운 과거에 참조되면 가까운 미래에 또 참조될 확률이 높다.

- 캐시와 메인메모리의 Common Case 예시
	- Spatial locality: 요청된 워드로 움직이지 않고 그 주변에 있는 block 단위로 캐시에 올려 놓는다. 
	- Temporal locality: 여태까지 참조된 블록을 줄을 세운다. 그 다음에 캐시에 집어넣을 수 있는 곳까지만 끊어서 올린다. 
	- 보통의 DRAM 2GB인데 캐시를 2MB만 써도 99% 참조가 캐시에서 hit가 나오는데 그 이유가 위 Common Case를 잡아냈기 때문

### Rule2: Rare 케이스는 성능보다 Correct
- CPU 캐시메모리 정확성에 문제가 될만한 Rare 케이스는 무엇?
	- I/O가 메인메모리(DRAM) 데이터 변경했는데 프로세서가 캐시에서 이전 데이터를 참조하는 잘못된 Rare 케이스
	- I/O Input작업이 끝나면 프로세서는 캐시가 아니라 메인메모리를 참조하고 캐시에 있는 이전 데이터는 지우도록 하여 해결 
 
## Performance 측정 방법

> 엔지니어링 95%는 정말 쉽다. 마지막 5%가 정말 어려운데 보통 5~10배 더 힘들다.  
>  정확성이 담보되었다면 성능을 최적화

- Performance types
- 1) 클라이언트가 중요하게 생각하는 메트릭
- 2) 서버가 중요하게 생각하는 메트릭

- Time
	- 클라이언트측에서 본 퍼포먼스 메트릭(중국집 손님)
	- response time
	- execution time
- Rate
	- 서버측에서 본 퍼포먼스 메트릭(중국집 주인)
	- throughput: MIPS, MFLOPS
	- bandwidth: Mbps
- Ratio
	- relative performance(both time and rate)

- Load Instruction
	- State: 타겟 레지스터의 값이 바뀌고 프로그램 카운터의 값이 바뀐다.
	- Operation: 메모리 내용을 레지스터로 옮긴다.

- Branch
	- State: 프로그램 카운터 
	- 조건 만족하면 어디로 브랜치할 것인지 타겟 주소 지정
	- 조건이 맞지 않으면 시퀀셜한 인스트럭션 실행

## Technology Trends 
- 1 MIPS(1초에 백만개 인스트럭션 실행)
- 64KB : 메모리
- 1M : 백만불 
- 가격 / MIPS: MIPS당 가격

> 더 큰 Mega-Trend
> - 창조주가 우리를 만드신 방법을 배우는 것
> -  한 번 프로그래밍한 뒤에 자체적 evolve하도록 내버려둔 것
> - 프로그래밍을 한 번 해두고 냅두는 게 가장 좋지 않을까
> - 생물학에 키워드가 있을지도 모른다. 생물을 꼭 들으라.
> - 지금 눈 앞 트렌드가 아니라 10년 100년 1000년 뒤 트렌드에 도전과제를 삼으라. 

## Sources

- [Computer Architecture - 서울대학교 민상렬 교수님](https://olc.kr/course/course_online_view.jsp?id=240)
- [컴퓨터 구조 및 설계](http://www.yes24.com/Product/Goods/102716854)

