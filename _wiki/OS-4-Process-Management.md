---
layout  : wiki
title   : 
summary : 
date    : 2022-02-13 00:07:21 +0900
updated : 2022-02-13 00:28:50 +0900
tags    : 
toc     : true
public  : true
parent  : 
latex   : false
---
* TOC
{:toc}

# 요약

1. 프로세스 생성(Process Creation)
- Who:
	- 부모 프로세스가 자식 프로세스 생성
	- fork나 exec(시스템콜)는 OS가 수행
- How: 복제 생성
	- 자식이 부모를 그대로 복사(OS data except PID + binary)하고 주소공간을 할당한 뒤 그 위에 새로운 프로그램을 올림
		- 복사: code, data, stack, CPU 문맥(어디까지 Instruction을 수행했는가) 레지스터인 프로그램 카운터, 
	- 일단 복제한 후(fork) 그 위에 새로운 프로그램을 올리는 것(exec)	
- What: 
	- 프로세스의 트리(계층 구조)가 삼각형 형태(부모 아래 자식들)로 형성
	- 3가지 자원의 공유 모델들(부모 자식 공유 O, 공유 X, 일부 공유)
		- 원칙 공유 X: CPU를 얻으려는 경쟁상태이므로
		- 그러나 공유하지 않으면 메모리 낭비가 발생할 수 있으므로 리눅스 같은 OS는 처음에는 공유한 후 서로 다른 CPU를 통한 Instructiond을 실행하면서 결국 각자의 길을 간다(부모 공간의 일부만 카피=COW(Copy on write)).
			- COW: 라이트가 발생했을 때 그때 카피를 해서 복사본을 쓰겠다. 그 이전까지는 부모 것을 그대로 공유한다.
	- 수행(Execution) 방식
		- 부모 자식 공존 or 자식 종료(terminate)까지 부모 기다리는 모델 

2. 프로세스 종료(Process Termination)

프로세스가 마지막 명령을 수행한 후 운영체제에게 이를 알려줌(Exit) - 자발적 종료
	- 예) main 함수의 중괄호를 닫는 코드가 암시적으로 Exit 시스템 콜	
	- 종료될 때 일어나는 일? 자식이 부모에게 wait 시스템콜을 통해 output data를 보냄(via wait)
		- 자식이 먼저 죽고 부모가 뒤치닥거리를 하는 구조
	- 프로세스의 각종 자원들이 운영체제에게 반납됨
부모 프로세스가 자식의 수행을 종료시킴(abort) - 비자발적 종료
	- 원인
	- 1) 자식이 할당 자원의 한계치를 넘어섬
	- 2) 자식에게 할당된 태스크가 더이상 필요하지 않음
	- 3) 부모가 종료해야 하는 경우
		- 운영체제는 부모 프로세스가 종료되는 경우 더이상 자식이 수행되도록 두지 않는다.
		- 단계적인 종료
			- 내가 죽는다고 자식을 모조리 먼저 죽인 다음 죽는다.

3. `fork()` 시스템 콜

수행과정
1)`fork()`를 하면 자식 프로세스가 생성되고
2) 자식 프로세스는 `fork()` 이전 코드의 문맥(프로그램 카운터 등)은 그대로 복사하므로 실행하지 않고 그 이후를 실행하는 것
3) `fork()` 이후 부모 PID>0, 자식 PID=0으로 구별

4. `exec()` 시스템 콜

어떤 프로그램을 완전히 새로운 프로세스로 태어나게 해준다.

1) `execlq()`를 실행하면  그 이전 기억은 다 잊어버리고 새롭게 시작
2) 한 번 이그젝하면 그 이전으로 돌아갈 수 없다.
> 여러 프로세스가 필요한 상황(?)에서 필요한 것인듯

5. `wait()` 시스템 콜

자식이 종료될 때까지 기다리는 시스템 콜
프로세스 A가 `wait()` 시스템 콜을 호출하면
	- 커널은 자식이 종료될 때까지 프로세스 A를 Sleep시킨다(block 상태)
	- 자식 프로세스가 종료되면 커널은 프로세스 A를 깨운다(ready 상태)
- 예) 커맨드 라인에서 명령어를 치면 명령어를 띄웠던 부모 프로세스는 명령어를 실행하는 자식 프로세스가 끝날 때까지 기다린다.

6. `exit()` 시스템 콜

프로세스의 종료
- 자발적 종료
	- 메인 함수의 괄호를 닫으면 암시적으로 프로세스 종료
- 비자발적 종료
	- 부모 프로세스가 자식 프로세스 강제 종료
		- 자식 프로세스 한계치 넘어서는 자원요청
		- 자식에게 할당된 태스크가 더이상 필요하지 않음
	- kill, break 등 강제 종료
	- 부모가 종료하는 경우 자식들을 먼저 종료시킴

7. 프로세스 간 협력
1) 독립적 프로세스(Independent process)
- 프로세스는 각자의 주소 공간을 가지고 수행되므로 원칙적으로 하나의 프로세스는 다른 프로세스의 수행에 영향을 미치지 못함

2) 협력 프로세스(Cooperating process)
- 프로세스 협력 메커니즘을 통해 하나의 프로세스가 다른 프로세스의 수행에 영향을 미칠 수 있음

3) 프로세스 간 협력 메커니즘(IPC: Interprocess Communication)
- 메시지 전달방법
	- message passing: 커널을 통해 메시지 전달
	- 프로세스는 독립적이므로 직접 메시지를 전달하지 못하고 커널을 통해 전달
		- Direct : 통신하려는 이름을 명시
		- Indirect : 통신하려는 이름을 명시 X, 우체통(or port)에 메시지를 넣는다. 
- 주소공간을 공유하는 방법
	- shared memory: 서로 다른 프로세스 간에도 일부 주소 공간을 공유하게 하는 shared memory 메커니즘이 있음
		- 처음에는 커널에 메모리 공유공간을 쓴다고 알려야 함
	- thread: 쓰레드는 사실상 하나의 프로세스이므로 프로세스 간 협력으로 보기는 어렵지만 동일한 프로세스를 구성하는 스레드 간에는 주소 공간을 공유하므로 협력 가능

# 프로세스 관리

## 프로세스 생성(Process Creation)
- Who: 부모 프로세스가 자식 프로세스 생성
- 프로세스의 트리(계층 구조) 형성
	- 삼각형 형태의 족보같은 구조
- 프로세스는 자원을 필요로 함
	- 운영체제로부터 받는다.
	- 부모와 공유한다.
- 자원의 공유
	- 부모와 자식이 모든 자원을 공유하는 모델
	- 일부를 공유하는 모델
	- 전혀 공유하지 않는 모델(일반적)
		- 일반적으로 서로 CPU를 얻으려는 경쟁상태가 되므로 공유하지 않는다.
- 수행(Execution)
	- 부모와 자식은 공존하며 수행되는 모델
	- 자식이 종료(terminate)될 때까지 부모가 기다리는 모델 

How: 복제 생성
- 일단 복제한 후(fork) 그 위에 새로운 프로그램을 올리는 것(exec)
- fork나 exec(시스템콜)는 OS가 수행
- 주소 공간
	- 자식은 부모의 공간을 복사함(binary and OS data)
	- 자식은 그 공간에 새로운 프로그램을 올림
- 유닉스의 예
	- `fork()` 시스템 콜이 새로운 프로세스를 생성
		- 부모를 그대로 복사(OS data except PID + binary)
		- 주소 공간 할당
	- fork 다음에 이어지는 `exec()` 시스템 콜을 통해 새로운 프로그램을 메모리에 올림

## 프로세스 종료(Process Termination)

프로세스가 마지막 명령을 수행한 후 운영체제에게 이를 알려줌(Exit) - 자발적 종료
	- 예) main 함수의 중괄호를 닫는 코드가 암시적으로 Exit 시스템 콜	
	- 종료될 때 일어나는 일? 자식이 부모에게 wait 시스템콜을 통해 output data를 보냄(via wait)
		- 자식이 먼저 죽고 부모가 뒤치닥거리를 하는 구조
	- 프로세스의 각종 자원들이 운영체제에게 반납됨
부모 프로세스가 자식의 수행을 종료시킴(abort) - 비자발적 종료
	- 이유?
	- 자식이 할당 자원의 한계치를 넘어섬
	- 자식에게 할당된 태스크가 더이상 필요하지 않음
	- 부모가 종료하는 경우
		- 운영체제는 부모 프로세스가 종료하는 경우 자식이 더이상 수행되도록 두지 않는다.
		- 단계적인 종료
			- 내가 죽는다고 자식을 먼저 모조리 죽인 다음 죽는다.
 
## fork() 시스템 콜
 
수행과정
1)`fork()`를 하면 자식 프로세스가 생성되고
2) 자식 프로세스는 fork() 이전 코드의 문맥(프로그램 카운터 등)은 그대로 복사하므로 실행하지 않고 그 이후를 실행하는 것
3) fork()이후 부모 PID>0, 자식 PID=0으로 구별

## exec() 시스템 콜

어떤 프로그램을 완전히 새로운 프로세스로 태어나게 해준다. 

1) `execlq()`를 실행하면  그 이전 기억은 다 잊어버리고 새롭게 시작
2) 한 번 이그젝하면 그 이전으로 돌아갈 수 없다.
3) 이그젝 이후의 코드는 실행되지 않을 것?

## wait() 시스템 콜

자식이 종료될 때까지 기다리는 시스템 콜
프로세스 A가 `wait()` 시스템 콜을 호출하면
	- 커널은 자식이 종료될 때까지 프로세스 A를 Sleep시킨다(block 상태)
	- 자식 프로세스가 종료되면 커널은 프로세스 A를 깨운다(ready 상태)
- 예) 커맨드 라인에서 명령어를 치면 명령어를 띄웠던 부모 프로세스는 명령어를 실행하는 자식 프로세스가 끝날 때까지 기다린다.

## exit() 시스템 콜

프로세스의 종료
- 자발적 종료
	- 메인 함수의 괄호를 닫으면 암시적으로 프로세스 종료
- 비자발적 종료
	- 부모 프로세스가 자식 프로세스 강제 종료
		- 자식 프로세스 한계치 넘어서는 자원요청
		- 자식에게 할당된 태스크가 더이상 필요하지 않음
	- kill, break 등 강제 종료
	- 부모가 종료하는 경우 자식들을 먼저 종료시킴

## 프로세스 간 협력
1) 독립적 프로세스Independent process)
- 프로세스는 각자의 주소 공간을 가지고 수행되므로 원칙적으로 하나의 프로세스는 다른 프로세스의 수행에 영향을 미치지 못함 

2) 협력 프로세스(Cooperating process)
- 프로세스 협력 메커니즘을 통해 하나의 프로세스가 다른 프로세스의 수행에 영향을 미칠 수 있음

3) 프로세스 간 협력 메커니즘(IPC: Interprocess Communication)
- 메시지 전달방법
	- message passing: 커널을 통해 메시지 전달
	- 프로세스는 독립적이므로 직접 메시지를 전달하지 못하고 커널을 통해 전달
		- Direct : 통신하려는 이름을 명시
		- Indirect : 통신하려는 이름을 명시 X, 우체통(or port)에 메시지를 넣는다. 
- 주소공간을 공유하는 방법
	- shared memory: 서로 다른 프로세스 간에도 일부 주소 공간을 공유하게 하는 shared memory 메커니즘이 있음
		- 처음에는 커널에 메모리 공유공간을 쓴다고 알려야 함
	- thread: 쓰레드는 사실상 하나의 프로세스이므로 프로세스 간 협력으로 보기는 어렵지만 동일한 프로세스를 구성하는 스레드 간에는 주소 공간을 공유하므로 협력 가능

# Source

- [이화여대 반효경 교수님 운영체제 강의](http://www.kocw.net/home/search/kemView.do?kemId=1046323)
(
