---
layout  : wiki
title   : 
summary : 
date    : 2022-06-18 17:40:14 +0900
updated : 2022-06-18 17:40:14 +0900
tags    : 
toc     : true
public  : true
parent  : 
latex   : false
---
* TOC
{:toc}

# 2. 변수의 타입 
- 기본형(Primitive type)
	- 논리형(boolean), 문자형(char), 정수형(byte, short, int, long), 실수형(float, double)
	- boolean을 제외한 나머지 7개 기본형은 서로 연산과 변환이 가능
	- 자료형(data type): 기본형 종류를 구분할 때
- 참조형(Reference type)
	- 객체의 주소를 저장, 8개 기본형을 제외한 나머지
	- 타입(type): 참조형 변수의 종류를 구분할 때

## 2.1 기본형(primitive type) 
- 기본형의 크기와 범위 https://hymndev.tistory.com/15
- char는 자바에서 유니코드(2바이트 문자체계)를 사용하므로 2바이트
- 저장 가능한 값의 범위 : -2^n-1 ~ 2^n-1 - 1(n은 자료형의 비트수)
	- 자료형 비트 크기에서 1을 빼는 이유는 맨 앞 비트를 부호로 나타내기 때문
	- 가능 범위에서 1을 빼는 이유는 중간에 0이 있기 때문
	- 예) int --> 32비트(4바이트) -2^31~2^31 - 1
- 저장 가능한 값의 범위 float, double은 비트 수로 계산 X
	- 저장형식이 달라서(소수점의 위치를 지수로 표현) 더 큰 값을 표현할 수 있으나 오차 발생
	- 10진수를 2진수로 바꾸면 무한소수가 되는 경우가 있음

- 실수형 정밀도
	- float 7자리, 4바이트
	- double 15자리, 8바이트

## 2.2 상수와 리터럴(constant & literal) / 30  

- 여러 단어로 이뤄진 경우 `_`로  구분

### 리터럴
- 상수: 값을 한 번만 저장할 수 있는 **공간**(값이 아니라)
- 리터럴: 그 자체로 값을 의미하는 것

```java
int year = 2014; //2014는 리터럴
final int MAX_VALUE = 100; //MAX_VALUE는 상수
```

### 리터럴 접미사
- long: l 또는 L 예) 100L
- double: d 또는 D(실수형은 double이 기본 자료형이라 접미사 생략 가능)
- 10의 제곱을 나타내는(E, e)가 있으면 실수형 리터럴
- 16진수: 0x or 0X
	- 실수 리터럴 16진수로 표현 시 p는 2의 제곱을 의미. p의 왼쪽에 16진수를 적고 오른쪽에 10진 정수를 적는다(잘 안 쓰임)
	- 0x1p1 --> `(1*16^0) * 2^1 = 1.0 * 2 = 2.0`
- 8진수: 0
- 2진수: 0b

```java
float pi = 3.14; // 소수 기본 자료형 doublue이므로 에러
```


### 문자 리터럴과 문자열 리터럴
- 문자열: 문자의 연속된 나열
	- "Java" : 문자열 리터럴
- 문자 리터럴: 작은따옴표로 감싼 하나의 문자
	- 'J' : 문자 리터럴

```java
string str = "";    //OK
char   ch  = '';   // 에러. ''안에는 반드시 하나의 문자가 필요
char   ch  = ' ';  //OK
```

- String의 덧셈 연산자 사용
	- 덧셈 연산자(+)는 피연산자 중 한 쪽이 String이면 나머지 한 쪽을 먼저 String으로 변환한 다음 두 String을 결합(기본형, 참조형 모두).
	- 예: true + "" --> "true"

### 형식화된 출력 - printf()
- 다른 형식으로 출력할 때
- println()과 달리 printf()는 출력 후 줄바꿈을 하지 않는다. '%n'을 따로 넣어줘야 한다.
```java
int finger = 10;
System.out.printf("[%5d]%n", finger);   // finger = [   10]
System.out.printf("[%-5d]%n", finger);  // finger = [10   ]
System.out.printf("[%05d]%n", finger);  // finger = [00010]

char c = 'A';
System.out.printf("c=%c, %d %n", c, int(c));  // c언어와 달리 형변환이 꼭 필요하다.
```
- 실수형 출력 지시자
	- %g : 값을 간략하게 표현
	- %f  : 소수점 아래 6자리까지만 출력하므로 7자리에서 반올림
	- %s : 숫자를 추가하면 원하는 만큼의 출력공간을 확보하거나 문자열의 일부만 출력할 수 있다.

### 2.4 화면에서 입력받기 - Scanner
```java
import java.util.*;

Scanner scanner = new Scanner(System.in); // Scanner 클래스의 객체를 생성
```

```java
String input = scanner.nextLine();  
int num = Integer.parseInt(input); // 문자열을 숫자로 변환 
```

- nextInt(), nextFloat()와 같이 변환없이 바로 입력받을 수 있는 메서드들 있지만 화면에서 연속으로 값을 입력받아서 사용하기에는 까다롭다.
```java
int num = scanner.nextInt();
```
    
# 3. 진법
## 3.2 비트(bit)와 바이트(byte)
- n비트로 표현 가능한 10진수
	- 개수: 2^n개
	- 범위: 0 ~ 2^n -1

## 3.3 8진법과 16진법
## 3.4 정수의 진법 변환
## 3.5 실수의 진법변환
## 3.6 음수의 2진 표현 - 2의 보수법

# 4. 기본형(primitive type)
## 4.1 논리형 - boolean
## 4.2 문자형 - char
- 문자가 아닌 문자의 유니코드(정수) 저장
- char: 0 ~ 2^16 -1
	- 2바이트(=16비트) 16자리 2진수로 표현 가능한 범위이므로 2^16(65536)에서 0을 포함하므로 0~65535까지 표현 가능
- short: -2^15 ~2^15 - 1
	- 문자는 음수를 나타낼 필요가 없었지만 정수형 short는 절반을 음수표현에 사용하므로 -32768~32767 범위

### 아스키(ASCII)
- American Standard Code for Information Interchange 미국 정보 교환 표준 부호
- 128개(2^7) 7비트 부호체계: 0~127까지 총 128까지 사용
- 7비트만 쓰는 이유는 1비트는 에러 검출 용도이므로

### 확장 아스키(Extended ASCII)와 한글
- 7비트에서 남은 1비트를 문자로 추가 정의

### 유니코드
- 전 세계 통일 문자집합
- 유니코드 인코딩
	- UTF-8: 1~4바이트 가변크기로 표현
		- 한글은 3바이트로 표현
	- UTF-16: 2바이트 고정 크기
		- 모든 문자 크기가 동일하여 다루기 편하지만 1바이트로 표현 가능한 영문과 숫자를 2바이트로 표현하므로 낭비

## 4.3 정수형 - byte, short, int, long

### 정수형 선택기준
- JVM 피연산자 스택(operand stack)이 피연산자를 4바이트 단위로 저장하므로 그보다 작은 byte, short보다 int로 연산하는 게 오히려 더 효율적

### 4.4 실수형 - float, double
- 정수형의 오버플로우, 실수형에서는 무한대 or 언더플로우
- float 정밀도 7자리(1234.567, 0.00001234567, 1234567000)

### 실수의 저장형식
- int는 값을 표현할 때 부호와 값, 실수는 부호(S), 지수(E), 가수(M)
- ±M * 2^E
- 부호 Sign bit: 정수형과 달리 2의 보수법을 사용하지 않으므로 0이면 양수 1이면 음수
- 지수 Exponent
	- float는 지수 저장용도로 8비트 저장공간
	- -127, 128은 NaN, Not a Number 등을 표현해야 하므로 실제 지수의 범위는 -126~127
- 가수 Mantissa
	- 가수: 실제 값을 의미
	- float 2진수 23자리, 10진수 7자리 저장 가능 --> 정밀도

## 5. 형변환 
- 기본형에서 boolean을 제외한 나머지 타입들은 서로 형변환 가능
- 기본형과 참조형은 서로 형변환할 수 없다.
- 서로 다른 타입 변수간의 연산은 형변환을 하는 것이 원칙이지만, 값의 범위가 작은 타입에서 큰 타입으로의 형변환은 생략할 수 있다. 

## Source

- [자바의 정석](https://www.aladin.co.kr/shop/wproduct.aspx?ItemId=76083001)

